To-Do and Reminders for hexdump implementation for Windows
===============================================================================================

High Priority
* Plan out the structure of the program (to the best of your ability) so that you're working towards
  something coherent.
* Rewrite the display functions -- not overly-complex, easier to comprehend, and more efficient (if 
  possible).
* Include simple argument-/option-parsing functionality using std::find (see saved stack overflow post),
  change behavior of program according to those options.
* Rather than determining the number of bytes to deal with in the diplay functions, read only the number of
  bytes specified by the user IN THE ACTUAL READ BYTES FUNCTION.

Low(er) Priority
* Improve the program's output (try experimenting with colors) -- make it more attractive.
* Add comments explaining decisions that aren't obvious if this needs to be done.

---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ----------

A Rough Outline of Current Code Organization As It Stands Now:
- Misc -- Small functions that perform miscellaneous tasks (setting number of digits in a number, getting the 
  system's endianness, etc.).
- File operations and data retrieval -- Get file size, read bytes from file, etc.
- Printing data from a file in various ways -- Print in little endian, print in big endian, print hex dump 
  (which chooses between the two former choices).

A Rough Outline of How You Could Reorganize Your Code:
- Misc -- Small functions that perform miscellaneous tasks (setting number of digits in a number, getting 
  the system's endianness, etc.).
- File operations and data retrieval -- Get file size, read bytes from file, etc.
- Print functions -- print the bytes read from a file in different ways -- little endian, big endian, 
  with or without ASCII. Try to avoid redundancy and repeated code!
- User input and command-line-option parser/handler function(s) -- self explanatory.
- Main function -- Print any text or info that doesn't fit into the above (greeting, explanation text, 
  status text), and use the above input functions to get input and call the appropriate print functions 
  based on that input, and print any error messages. 

---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ----------

General Program Outline
- Get input in the form of 
  program [-options] <file>
- Read the specified number of bytes from the file, store them in a vector
- Pass options to a general 'display' function, which will decide which specific format to display the bytes in
  based on the program options, and call the appropriate specific display function. 
~ Make sure to implement adequate error checking. 

--- --- --- 

Command-Line Options
* -n, --length <length>		number of bytes to read from the file
* -C, --canonical			canonical hex+ascii display
* -h, --help				display a help screen listing possible options
* -v, --version				display program version 
* -m, --color mode <mode>	set the color mode: off or on

--- --- --- 

The two display modes you'll need for this simple implementation are the default (hexadecimal output -- either 
little-endian or big-endian depending on user's system) and canonical (little-endian + ascii). So, actually three
different display modes: little-endian, big-endian, and little-endian+ascii. These will probably have to be 
implemented in three separate functions. 

The default mode will group bytes into 16-bit (2-byte) groups, like the 'original' hexdump program on Linux.
These 16-bit groups will be arranged in little- or big-endian according to the user's system's endianness.
The canonical mode will group bytes into 8-bit (1-byte) groups. 

---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ----------

DisplayCanonical() Function (Using hexdump's output for reference)

- Individual bytes, not groups of two bytes, are separated by a space.
- Every 1/2 rowSize, an extra space is printed (there is a defined space halfway between the rows).

- After each row, start a loop that prints the rowSize bytes that were just printed and stops when 
  rowSize ASCII characters are printed.
